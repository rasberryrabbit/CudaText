=Intro=
This is API for [[CudaText]] in Python. 

* Main Py module is cudatext. Main module has constants, funcs, class Editor, objects of class Editor.
* Additional module: cudatext_cmd has constants for command runner func.

=Event plugins=

To make plugin react to events, add method to class Command (like methods of command plugin). E.g. method "on_save" will be called by editor event on_save. Event methods have additional parameter ed_self: Editor object in which event occured (this object is the same as "ed" in 99% cases, but in rare cases event occurs in non-focused editor).

Supported events:

* on_open(self, ed_self): Called after file is opened from disk.
* on_save_pre(self, ed_self): Called before saving file. Method can return False to disable saving, other value is ignored.
* on_save(self, ed_self): Called after saving file.
* on_change(self, ed_self): Called after text is changed.
* on_change_slow(self, ed_self): Called after text is changed, after few seconds. This is for Lint plugins, they need to react to change after a delay.
* on_caret(self, ed_self): Called after caret position/selection changed.
* on_click(self, ed_self, state): Called after mouse click. state has the same meaning as in on_key.
* on_key(self, ed_self, key, state): Called when user presses a key. key is int key code. state is string of chars: "a" if Alt pressed, "c" if Ctrl pressed, "s" if Shift pressed, "m" if Meta (Windows-key) pressed. Method can return False do disable key processing, other return value is ignored.
* on_focus(self, ed_self): Called after editor is focused.
* on_lexer(self, ed_self): Called after lexer is changed.
* on_start(self, ed_self): Called once on program start (ignore ed_self).

Code parsing

* on_complete(self, ed_self): Called by auto-completion command (default hotkey: Ctrl+Space). Method should call Editor.complete API. Method must return True if it handled command, otherwise None.  
* on_goto_def(self, ed_self): Called by go-to-definition command (in editor context menu). Method must return True if it handled command, otherwise None.
* on_func_hint(self, ed_self): Called by function-hint command (default hotkey: Ctrl+Shift+Space). Method must return function-hint string (comma-separated parameters, brackets are optional). Empty str or None means no hint found.

Panels

* on_console(self, ed_self, text): Called on entering text command in Python Console panel. Method can return False to disable internal command processing, other value is ignored. Ignore ed_self.
* on_console_nav(self, ed_self, text): Called on dbl-clicking line, or calling context menu item "Navigate", in Python Console panel. Ignore ed_self. Text is line with caret.
* on_output_nav(self, ed_self, text, tag): Called on clicking line, or pressing Enter, in Output or Validate panel. Ignore ed_self. Text is clicked line, tag is int value associated with line. Event is called only if app cannot parse output line by itself using given regex (or regex isn't set at all).

Macros

* on_macro(self, ed_self, text): Called when command "macros: stop recording" runs. In text the "\n"-separated list of macro items is passed. These items were run after command "macros: start recording" and before command "macros: stop recording".
** if item is "number" then it's simple command.
** if item is "number,string" then it's command with str parameter (usually it's command cCommand_TextInsert).
** if item is "py:string_module,string_method,string_param" then it's call of Python plugin (usually string_param is empty).
** to run each item in log, call ed.cmd(): number is command code, all after comma is parameter text.

Notes

Config plugins.json: Command plugins need registering in section "commands", event plugins need registering in section "events". Event plugins have optional key "lexers" - e.g. "CSS,HTML"; need key "events" - e.g. "on_key,on_open,on_save".

=Global funcs=

===version===

 app_exe_version()

Gets version of program (string).

 app_api_version()

Gets version of API (string, contains 3 numbers, dot-separated).

===app_path===

 app_path(id)

Gets some path. Possible values of id:

* APP_DIR_EXE: Dir of program executable.
* APP_DIR_SETTINGS: Dir "settings".
* APP_DIR_DATA: Dir "data".
* APP_DIR_PY: Dir with Python data "py".
* APP_FILE_SESSION: Filename of session, default is "history session.json" in dir "settings".

===app_proc===

 app_proc(id, text)

Performs application-wide action. Possible values of id:

====Misc====

* PROC_GET_CLIP: Gets clipboard text.
* PROC_SET_CLIP: Copies text to clipboard.
* PROC_GET_GROUPING: Gets grouping mode in program, it's one of GROUPS_nnnn int contants.
* PROC_SET_GROUPING: Sets grouping mode in program, pass str(value) where value is one of GROUPS_nnnn int contants.
* PROC_GET_COMMAND: Gets info on internal command with index int(text), 0-based. Gets tuple: (command_int_code, command_name, hotkey_str_1, hotkey_str_2), or None if index not correct. To enum all commands, increase index from '0', until you get None result.
* PROC_GET_ESCAPE: Gets escape flag (bool). This flag is set when user presses Esc key (each Esc press is counted since app start, you need to clear flag). To allow app to handle key press, you must call msg_status() in loop.
* PROC_SET_ESCAPE: Sets escape flag ("0"/"1").
* PROC_GET_FIND_OPTIONS: Gets options of finder-object as string.
* PROC_SET_FIND_OPTIONS: Sets options of finder-object from string. Note: Find dialog don't apply these opts immediately.

====Plugin calls====

* PROC_SET_EVENTS: Subscribe plugin to events. Param text must be 4 values ";"-separated: "module_name;event_list;lexer_list;keycode_list". Event_list is what can be written in plugins.json, e.g. "on_open,on_save" or empty str to unsubscribe from all. Lexer_list, keycode_list is what can be written in plugins.json too.
* PROC_GET_LAST_PLUGIN: Gets info about last plugin which run from program. It is str "module_name,method_name", values are empty if no plugins run yet.
* PROC_SET_SUBCOMMANDS: Adds command items for plugin (for fixed module/method). Param text must be ";"-separated: "module_name;method_name;param_list". Param_list is "\n"-separated items. Each item is s_caption+"\t"+s_param_value. s_caption is caption for Commands dialog item, s_param_value is parameter for Python method (it can be any primitive type: 20, None, False, 'Test here', or expression).
* PROC_GET_COMMAND_PLUGIN: Allows to enumerate all command plugins (and items from PROC_SET_SUBCOMMANDS). Call it with str(N) from N=0 until you get None. Gets 5-tuple about N-th item (caption, module, method, param, lexers).

====Python====
* PROC_EXEC_PYTHON: Runs Python string in the context of Console (it is not the same as exec() call). Also gets string: result of command.
* PROC_EXEC_PLUGIN: Runs Python plugin's method. Text must be ","-separated: "module_name,method_name,param_string", where param_string can be missed, this is parameter(s) for method.

====Sessions====

* PROC_SAVE_SESSION: Saves session to file with given name. Session is a set of opened named files, group-indexes for files, positions of groups. Session files are JSON.
* PROC_LOAD_SESSION: Loads session from file with given name. 
* PROC_SET_SESSION: Tells to app filename of session. This file will be saved on exit, loaded on start, shown in app title in {} brackets.

====Menus====

* PROC_MENU_ENUM: Gets "\n"-separated string with all items in submenu. Items in form "caption|int_command" or in form "caption|s_module,s_method". Param text must be menu_id.
** menu_id can be: 
*** str(int_value) to specify any submenu by unique int value
*** "top" to specify top menu
*** "top-file"/"top-edit"/"top-sel"/"top-sr"/"top-view"/"top-op"/"top-help" to specify submenus File/Edit/Selection/Search/View/Options/Help
*** "text" to specify editor context menu

* PROC_MENU_CLEAR: Clears some submenu. Param text must be menu_id.

* PROC_MENU_ADD: Adds menu item to some submenu. Param text must be "menu_id;menu_cmd;menu_caption;menu_index". This returns string, str(int_value), with unique int value for added item. Use this string as menu_id for next calls.
** menu_id is submenu item in which you add item. 
** menu_cmd is:
*** str(command_code) - int command code from module cudatext_cmd
*** spec values: 
**** "recents" - recent-files submenu; 
**** "themes" - color-themes submenu; 
**** "plugins" - plugins submenu
*** s_module+","+s_method - method in command plugin. Also allowed to add here ","+s_param - to pass parameter to Python method.
*** 0 (value ignored) if submenu
** menu_caption is caption, or "-" for menu separator.
** menu_index is str(index) for 0-based index at which to insert item; empty param or -1: add item at end.

====Splitters====

* PROC_GET_SPLIT: Gets info about splitter position, 4-tuple: (is_vertical_0_1, is_visible_0_1, splitter_pos, parent_panel_size). Text must be splitter id (incorrect value gives parent_panel_size=0).
* PROC_SET_SPLIT: Sets position of splitter. Text must be "splitter_id;splitter_pos".

Splitter id can be:
* "L": left splitter (near Side panel)
* "B": bottom splitter (near Bottom panel)
* "G1"..."G3": splitters between groups. Note: positions are determined by grouping view, in one view splitter may be horizontal with one parent panel, in other view - vertical with another parent panel.

How groups-splitters are placed in views:
<pre>
2VERT     t G1 t          
2HORZ     t               
          G1              
          t               
3VERT     t G1 t G2 t     
3HORZ     t               
          G1              
          t               
          G2              
          t               
3PLUS     t G3 t          
               G2         
               t          
4VERT     t G1 t G2 t G3 t
4HORZ     t               
          G1              
          t               
          G2              
          t               
          G3              
          t               
4GRID     t G1 t          
          G3              
          t G2 t          
6GRID     t G1 t G2 t     
          G3              
          t G1 t G2 t     
</pre>

===app_log===

 app_log(id, text, tag=0)

Controls panels in the bottom panel: Console, Output, Validate, and additional panels.

Possible values of id:

* LOG_CLEAR: Clears active log panel, text is ignored.
* LOG_ADD: Adds line to active log panel. Param tag is used here: it's int value associated with line, it's passed in on_output_nav.
* LOG_SET_PANEL: Sets active log panel. Text must be LOG_PANEL_OUTPUT, LOG_PANEL_VALIDATE, or caption of additional panel (see LOG_PANEL_ADD). Incorrect text will stop next operations with panels, until correct value set.
* LOG_SET_REGEX: Sets parsing regex for active log panel. Regex must have some groups in round brackets, indexes of these groups must be passed in separate API calls. All lines in log panel, which can be parsed by this regex, will allow navigation to source code by click or double-click.
* LOG_SET_LINE_ID: Sets index of regex group for line-number. text is one-char string from "1" to "8", and "0" means "not used".
* LOG_SET_COL_ID: Sets index of regex group for column-number.
* LOG_SET_NAME_ID: Sets index of regex group for file-name.
* LOG_SET_FILENAME: Sets default file-name, which will be used when regex cannot find file-name in a string. 
* LOG_SET_ZEROBASE: Sets flag: line and column numbers are zero-based, not 1-based. text is one-char string "0" or "1".
* LOG_GET_LINES: Gets str: "\n"-separated lines in listbox. Each line is text+"\r"+str(tag).
* LOG_GET_LINEINDEX: Gets index of selected line in listbox.
* LOG_SET_LINEINDEX: Sets index of selected line in listbox.
* LOG_PANEL_ADD: Adds new panel next to Output/Validate. Text is caption of panel. Gets True if panel was added; gets False for incorrect caption: caption of standard or already added panel.
* LOG_PANEL_DELETE: Deletes panel added with LOG_PANEL_ADD. Text is caption of panel. Gets True if panel found and deleted.
* LOG_PANEL_FOCUS: Focuses panel added with LOG_PANEL_ADD. Text is caption of panel. Gets True if panel found and focused.

For "Python console" panel:

* LOG_CONSOLE_CLEAR: Clears console (both controls of console: combobox and read-only memo).
* LOG_CONSOLE_ADD: Adds line to console (combobox and memo).
* LOG_CONSOLE_GET: Gets list of lines in console combobox.

Example for regex:

For line "line 10 column 20: text message here" the following regex and indexes can be used:

* regex "\w+ (\d+) \w+ (\d+): .+"
* line-number index "1"
* column-number index "2"
* file-name index "0" (not used)
* zero-base flag "0" (off)

===msg_box===

 msg_box(text, flags)

Shows modal message-box with given text.

Param flags is sum of button-value (OK, OK/Cancel, Yes/No etc) and icon-value (Info, Warning, Error, Question):

* MB_OK
* MB_OKCANCEL
* MB_ABORTRETRYIGNORE
* MB_YESNOCANCEL
* MB_YESNO
* MB_RETRYCANCEL

* MB_ICONERROR
* MB_ICONQUESTION
* MB_ICONWARNING
* MB_ICONINFO

Gets int code of button pressed:

* ID_OK
* ID_CANCEL
* ID_ABORT
* ID_RETRY
* ID_IGNORE
* ID_YES
* ID_NO

===msg_status===

 msg_status(text)

Shows given text in statusbar field.

===msg_status_alt===

 msg_status_alt(text, seconds)

Shows given text in alternative statusbar, just above normal statusbar. Status has entire window width. Status shows only for some seconds (1..30).

===dlg_input===

 dlg_input(label, defvalue)

Shows modal dialog to input one string.

Gets entered string or None of cancelled.

===dlg_input_ex===

 dlg_input_ex(number, caption,
               label1   , text1="", label2="", text2="", label3="", text3="",
               label4="", text4="", label5="", text5="", label6="", text6="",
               label7="", text7="", label8="", text8="", label9="", text9="",
               label10="", text10="")

Shows modal dialog to enter 1 to 10 strings. Param number is count of strings.

Gets list of entered strings or None if cancelled.

===dlg_file===

 dlg_file(is_open, init_filename, init_dir, filters)

Shows file-open or file-save-as modal dialog.

Gets filename (str) or None if cancelled. Params:

* is_open: True for open dialog, False for save-as dialog.
* init_filename: Initial filename for save-as dialog. Can be empty.
* init_dir: Initial dir for dialog. Can be empty.
* filters: Sets file filters for dialog. Can be empty. Example, 2 filters: "Texts|*.pas;*.txt|Include|*.inc"

To allow multi-select in open dialog, pass init_filename="*". If single filename selected, result is str. If several filenames selected, result is list of str.

To disable check "filename exists" in open dialog, start init_filename with "!".

===dlg_menu===

 dlg_menu(id, text, focused=0)

Shows menu dialog.
Gets index of selected item (0-base), or None of cancelled. Param focused is index of initial item.

Possible values of id:

* MENU_LIST: Dialog with listbox similar to Commands dialog of CudaText, with filter field.
* MENU_LIST_ALT: Like MENU_LIST but each item has 2x height, and instead of right-aligning, part of an item shows below.

Param text is string items, separated by "\n" char. Each item can be simple str or str1+"\t"+str2 (str2 shows right-aligned or below).

===dlg_color===

 dlg_color(value)

Shows select-color dialog with given initial color (int).

Gets int color, or None if cancelled.

===dlg_hotkeys===

 dlg_hotkeys(text)

Shows dialog to configure hotkeys of internal command or plugin. Gets bool: OK pressed and hotkeys saved (to keys.json).

Text can be:

* str(int_command): for internal command codes (module cudatext_cmd).
* "module_name,method_name" or "module_name,method_name,method_param": for command plugin.

===dlg_custom===

 dlg_custom(title, size_x, size_y, text, focused=-1)

Shows dialog with controls of many types.

Parameter text is "\n"-separated items, one item per control. Each item is chr(1)-separated props. Each prop is s_name+"="+s_value. Possible names (and names' values):

* "type": type of control, values:
** "label"
** "check" (checkbox)
** "radio" (radiobutton, only one is checked)
** "edit" (one-line edit)
** "combo" (combobox editable, value is text)
** "combo_ro" (combobox read-only, value is index)
** "listbox"
** "button"
** "memo" (multi-line edit)
** "checkgroup" (group of checkboxes)
** "radiogroup" (group of radiobuttons)
** "checklistbox" (listbox with checkboxes)
** "spinedit" (edit for numbers, has min-value, max-value, increment)
** "listview" (list with columns, with column headers, value is index)
** "checklistview" (listview with checkboxes, value is check-flags)

* "en": enabled-state of control, "1"/"0" for on/off
* "pos": position of control, ","-separated values: left, top, right, bottom (e.g. "10,10,200,30"); some one-line controls ignore bottom-value and do autosize
* "cap": caption of control (not for all)

* "items": 
** for combo, combo_ro, listbox, checkgroup, radiogroup, checklistbox: "\t"-separated lines
** for listview, checklistview: "\t"-separated items.
*** first item is column headers: title1+"="+size1 + "\r" + title2+"="+size2 + "\r" +... 
*** size1...sizeN can be with lead char to specify alignment of column: L (default), R, C
*** other items are data: cell1+"\r"+cell2+"\r"+... (count if cells may be less than columns)

* "props": control-specific properties:
** for button: default_for_enter (bool value, "1"/"0")
** for edit, memo: read_only+","+font_monospaced+","+show_border (bool values, "1"/"0")
** for spinedit: str(min_value)+","+str(max_value)+","+str(increment)

* "val": value of control (not for all):
** for check, radio: value "0"/"1"
** for edit, combo, spinedit: text
** for memo: "\t"-separated lines (in lines "\t" must be replaced to chr(2))
** for combo_ro, listbox, radiogroup, listview: index
** for checkgroup: ","-separated checks (values "0"/"1")
** for checklistbox, checklistview: index+";"+checks

Parameter focused is index of control (0-base) which is focused on showing.

Dialog is closed by any button. Gets 2-tuple: (button_index, state_text), gets None if cancelled by "x".

* button_index: index of control (in text) for pressed button
* state_text: "\n"-separated values of controls (same count of items as in text)

Notes:

* Controls sizes differ on Win/Linux/OSX, picture shows controls (Linux/Win) auto-aligned, not in CudaText, only example app:

[[File:controls_autosizes.png]]

===file_open===

 file_open(filename, group=-1)

Opens editor tab with given filename. If filename already opened, activates its tab. Pass empty str to open untitled tab.

Param group is index of tab-group (0-based), default means "current group". If you pass index of currently hidden group, group won't show, you need to call editor command to show it, see [[#cmd]].

Gets bool: filename is empty or sucessfully opened.

Note: "ed" is always the current editor, after file_open() current editor changes, and "ed" is the new cur editor.

===file_save===

 file_save()

Saves current tab to disk. Shows save-as dialog for untitled tab. Gets bool: file was saved.

===ed_handles===

 ed_handles()

Gets range object: it contains int handles of all editor tabs. Pass each handle to Editor() to make editor object from handle.

Example command in console, prints filenames of all tabs:

<syntaxhighlight>
for h in ed_handles(): print(Editor(h).get_filename())
</syntaxhighlight>

===ini_read/ini_write===

 ini_read(filename, section, key, value)
 ini_write(filename, section, key, value)

Reads or writes single string to ini file. Params:

* filename: Full path of ini file. Can be name w/o path, this means that path of "settings" dir is used.
* section: str: Section of ini file.
* key: str: Key in section.
* value: On write: value to write. On read: default value which is returned if no such filename/section/key is found.

Gets string which is read, gets None on write.

===lexer_proc===

 lexer_proc(id, value)

Do some lexer-related action, get/set property. 

Parameter value gives ";"-separated substrings. Lexer name, if it's needed, is 1st substring. If lexer name needed and incorrect name passed, function gets None.

Possible values of id:

* LEXER_GET_EXT: Gets file-extensions field for given lexer, space-separated.
* LEXER_GET_ENABLED: Gets enabled-flag for given lexer. True means checkmark in lexer-library dialog (so lexer is visible in menu).
* LEXER_GET_COMMENT: Gets line-comment string for given lexer.
* LEXER_GET_MODIFIED: Gets bool: is lexer library modified and not saved.
* LEXER_GET_LIST: Gets string: "\n"-separated list of lexer names in library.   
* LEXER_GET_LINKS: Gets string: "\n"-separated list of sublexers names in the given lexer. 
* LEXER_GET_STYLES: Gets string: "\n"-separated list of styles names in the given lexer.
* LEXER_SET_NAME: Sets for lexer with given name (substring 1) new name (substring 2).
* LEXER_SET_ENABLED: Sets for lexer with given name enabled-flag (substring 2: "0" or "1").
* LEXER_SET_EXT: Sets for lexer with given name file-extensions field (substring 2).
* LEXER_SET_LINKS: Sets for given lexer - names of its sublexers. Substring 2 must be "|"-separated list of lexer names (any number allowed, only actual number will be used).
* LEXER_SAVE_LIB: Saves lexer library file.
* LEXER_DELETE: Deletes given lexer from library.
* LEXER_IMPORT: Adds new lexer from given filename (substring 1). Gets name of this lexer, or None if import failed.
* LEXER_EXPORT: Saves lexer with given name into file with given name (substring 2). Recommended extension: .lcf.

===more===

=Editor class=

Editor class has methods to work with editor. Global objects of Editor exist:

* ed: refers to currently focused editor (for any tab)
* ed_bro: refers to "brother" of ed. If tab is splitted, 2 editors are shown: 1st/2nd. 1st and 2nd are "brother" editors.

==Carets==
===get_carets===

 get_carets()

Returns list of 4-tuples, each item is info about one caret: (PosX, PosY, EndX, EndY).

* PosX is caret's column (0-base). Tab-chars give x increment 1, like others.
* PosY is caret's line (0-base).
* EndX/EndY is position of selection edge for this caret. Both -1 if no selection for caret.

===set_caret===

 set_caret(posx, posy, endx=-1, endy=-1, id=CARET_SET_ONE)

Controls carets. Possible values of id:

* CARET_SET_ONE: Removes multi-carets and sets single caret with given coords (posx, posy, endx, endy). 
* CARET_ADD: Adds caret (multi-carets feature) with given coords. Also gets count of carets after that (same as len(get_carets()) ).
* CARET_DELETE_ALL: Removes all carets. (Note: you must add caret then to enable text editing to user.)
* CARET_SET_INDEX + N (any N>=0): Changes single caret with index N to given coords.

==Text read/write==

===get_text_all/set_text_all===

 get_text_all()
 set_text_all(text)

Gets/sets entire text in the editor (str).

Note: get_text_all is simple wrapper around get_text_line/get_line_count, it uses "\n" as line sep.

===get_text_line/set_text_line===

 get_text_line(num)
 set_text_line(num, text)

Gets/sets single line (str) with given index (0-base).

Line must be w/o CR LF. Gets None if index incorrect.

To add new line, call set with num=-1.

===get_text_substr===

 get_text_substr(x1, y1, x2, y2)

Gets substring from position (x1, y1) to position (x2, y2). Second position must be bigger than first.

===delete===

 delete(x1, y1, x2, y2)

Deletes range from position (x1, y1) to bigger position (x2, y2). (Too big x1/x2 are allowed).

Note: don't pass tuple from get_carets()[0], this tuple has not sorted pos=(x1, y1), end=(x2, y2), you need to sort them (first sort by y, then by x).

Example replaces selection of 1st caret with text:

<syntaxhighlight lang="Python">
        x0, y0, x1, y1 = ed.get_carets()[0]
        if (y1>y0) or ((y1==y0) and (x1>=x0)):
            pass
        else:
            x0, y0, x1, y1 = x1, y1, x0, y0 
        
        ed.set_caret(x0, y0)
        ed.delete(x0, y0, x1, y1)
        ed.insert(x0, y0, text)
</syntaxhighlight>

===insert===

 insert(x, y, text)

Inserts given text at position (x, y). Text can be multi-line, all CR LF are converted to currently used line-ends.

Gets 2-tuple (x, y) of position after inserted text. It is on the same line, if text is single line.

==Selection==

===get_text_sel===

 get_text_sel()

Returns selected text for 1st caret (empty, if no selection).

===get_sel_mode===

 get_sel_mode()

Gets kind of selection: normal or column selection: SEL_NORMAL, SEL_COLUMN.

===get_sel_lines===

 get_sel_lines()

Gets 2-tuple, indexes of 1st and last lines affected by 1st caret selection. Both -1 if no selection.

===get_sel_rect/set_sel_rect===

 get_sel_rect()
 set_sel_rect(x1, y1, x2, y2)

Gets/sets coords of column selection.

Gets 4-tuple (x1, y1, x2, y2). All 0 if no column selection.

==Properties==

===get_line_count===

 get_line_count()

Gets number of lines.

===get_filename===

 get_filename()

Gets filename (str) of the editor's tab. Empty str for untitled tabs.

===get_tabcolor/set_tabcolor===

 get_tabcolor()
 set_tabcolor(value)

Gets/sets custom color (int) of tab for the editor. It's COLOR_NONE if color is not set.

===get_enc/set_enc===

 get_enc()
 set_enc(value)

Gets/sets encoding name for the editor. It's one of the strings which are visible in the encodings menu of statusbar: "UTF-8", "ANSI" etc.

===get_top/set_top===

 get_top()
 set_top(value)

Gets/sets index of top visible line in the editor.

===get_split/set_split===

 get_split()
 set_split(state, percent)

Gets/sets tab splitting: each tab can be splitted to primary/second editors.

Gets 2-tuple:

* int: state of splitting, one of the values
** TAB_SPLIT_NO: tab not splitted
** TAB_SPLIT_HORZ
** TAB_SPLIT_VERT 
* float: percent of splitting, it's 0.5 if tab splitted 50/50.

===get_prop===

 get_prop(id, text="")

Gets editor's property. 

Param text gives additional parameter(s) if mentioned. Possible values of id:

* PROP_GUTTER_NUM: bool: is gutter column for line numbers shown.
* PROP_GUTTER_FOLD: bool: is gutter column for folding shown.
* PROP_GUTTER_BM: bool: is gutter column for bookmarks shown.
* PROP_EOL: str: end-of-line chars. Currently always gets "\n" since it's ignored in "insert" method.
* PROP_WRAP: int: word-wrap mode. 0: no wrap; 1: wrap at window edge; 2: wrap at fixed margin.
* PROP_RO: bool: read-only mode.
* PROP_TAB_SPACES: bool: tab-key enters spaces.
* PROP_TAB_SIZE: int: size of tab-char.
* PROP_MARGIN: int: position of fixed margin.
* PROP_MARGIN_STRING: str: user-defined margins positions, e.g. "20 25".
* PROP_INSERT: bool: insert/overwrite mode.
* PROP_MODIFIED: bool: editor is modified.
* PROP_RULER: bool: horz ruler is shown.
* PROP_LINE_STATE: int: state of the line with index int(text). One of values: LINESTATE_NORMAL, LINESTATE_CHANGED, LINESTATE_ADDED, LINESTATE_SAVED.
* PROP_COLOR: int: color property. Text must be one of COLOR_ID values, see module cudatext_colors. Gets None for incorrect id.
* PROP_LEXER_FILE: str: name of lexer for entire file (empty str if none is active).
* PROP_LEXER_POS: str: name of lexer at specified position: text must be str(column)+","+str(line), column/line 0-based.
* PROP_LEXER_CARET: str: name of lexer at the position of 1st caret.
* PROP_INDEX_GROUP: int: index of group with editor's tab, 0-based.
* PROP_INDEX_TAB: int: index of editor's tab in group, 0-based.
* PROP_UNPRINTED_SHOW: bool: unprinted chars: global enable-flag.
* PROP_UNPRINTED_SPACES: bool: unprinted chars: show spaces/tabs.
* PROP_UNPRINTED_ENDS: bool: unprinted chars: show line ends.
* PROP_UNPRINTED_END_DETAILS: bool: unprinted chars: show line end details.
* PROP_TAB_COLLECT_MARKERS: bool: tab-keys collects (jumps to and deletes) markers (if markers placed).
* PROP_TAG: str: just a string attached to editor's tab (you can put here any value).
* PROP_CARET_SHAPE: int: shape of caret, normal mode.
* PROP_CARET_SHAPE_OVR: int: shape of caret, overwrite mode.
* PROP_CARET_SHAPE_RO: int: shape of caret, read-only mode.
* PROP_MACRO_REC: bool: currently macro is recording.
* PROP_MARKED_RANGE: 2-tuple: numbers of lines for "marked range" (both -1 if not set).

===set_prop===

 set_prop(id, value)

Sets editor's property.

Param value is str. If needed bool - pass "0"/"1"; if needed int - pass str(int_value).
Possible values of id:

* PROP_GUTTER_NUM: bool: show gutter column "line numbers".
* PROP_GUTTER_FOLD: bool: show gutter column "folding".
* PROP_GUTTER_BM: bool: show gutter column "bookmarks".
* PROP_WRAP: int: word-wrap mode. 0: no wrap; 1: wrap at window edge; 2: wrap at fixed margin. 
* PROP_RO: bool: read-only mode.
* PROP_TAB_SPACES: bool: tab-key enters spaces.
* PROP_TAB_SIZE: int: size of tab-char.
* PROP_MARGIN: int: position of fixed margin.
* PROP_MARGIN_STRING: str: space-separated user-margins columns.
* PROP_INSERT: bool: insert/overwrite mode.
* PROP_RULER: bool: show ruler.
* PROP_COLOR: color property, value must be "color_id,color_int_value", where color_id is constant from module cudatext_colors.
* PROP_LEXER_FILE: str: name of lexer.
* PROP_INDEX_GROUP: int: index of group with editor's tab, 0-based.
* PROP_INDEX_TAB: int: index of editor's tab in group, 0-based.
* PROP_UNPRINTED_SHOW: bool: unprinted chars: global enable-flag.
* PROP_UNPRINTED_SPACES: bool: unprinted chars: show spaces/tabs.
* PROP_UNPRINTED_ENDS: bool: unprinted chars: show line ends.
* PROP_UNPRINTED_END_DETAILS: bool: unprinted chars: show line end details.
* PROP_TAB_COLLECT_MARKERS: bool: tab-keys collects (jumps to and deletes) markers.
* PROP_TAG: str: just a string attached to editor's tab (you can put here any value).
* PROP_CARET_SHAPE: int: shape of caret, normal mode.
* PROP_CARET_SHAPE_OVR: int: shape of caret, overwrite mode.
* PROP_CARET_SHAPE_RO: int: shape of caret, read-only mode.
* PROP_EXPORT_HTML: this is not property, this is action to export text with hiliting to HTML. Value is ";"-separated parameters: "file_path;page_title;font_name;font_size;bool_show_numbers;int_color_background;int_color_numbers".
* PROP_MARKED_RANGE: str: numbers of lines for "marked range" as "num1,num2" (pass empty str or "-1,-1" to remove range).

===bookmark===

 bookmark(id, nline, nkind=1, ncolor=-1, icon="")

Controls bookmarks. Possible values of id:

* BOOKMARK_GET: Gets kind of bookmark at line=nline. 0 means no bookmark, 1 means usual bookmark.
* BOOKMARK_SET: Sets bookmark with kind=nkind at line=nline. 1 means usual bookmark with usual color and icon. Other kind values mean custom bookmark, which must be setup via BOOKMARK_SETUP.
* BOOKMARK_CLEAR: Removes bookmark from line=nline (nkind ignored).
* BOOKMARK_CLEAR_ALL: Removes all bookmarks (nline, nkind ignored).
* BOOKMARK_SETUP: Setup custom bookmarks with kind=nkind (nline ignored). Setup is:
** ncolor: color of bookmarked line. Can be COLOR_NONE to not show bg-color.
** icon: path to icon file for gutter, .bmp file of size 16x16.
* BOOKMARK_GET_LIST: Gets list of line indexes with bookmarks (nline, nkind ignored).

Notes:

* nkind must be 1..255.
* nkind values 240..249 have setup by default: they have blue icons "0" to "9".

===get_ranges===

 get_ranges()

Gets list of fold-ranges in parsed lexer data. It is list of 5-lists: [y, y2, x, staple, folded].

* y: line of range start.
* y2: line of range end. If y==y2, then range is simple and don't have gutter-mark and staple.
* x: x-offset of range start (char index in start line).
* staple: int (0/1) which shows that range has block staple.
* folded: int (0/1) which shows that range is currently folded.

===markers===

 markers(id, x=0, y=0, tag=0, len=0)

Controls markers (used e.g. in Snippets plugin). Possible values of id:

* MARKERS_GET: Gets list of markers, each item is list [x, y, tag, len]. Gets None if no markers.
* MARKERS_ADD: Adds marker. Also gets number of markers. Props:
** x, y: Start of marker (like caret pos).
** Param tag>0 is needed if you want to place multi-carets when command "goto last marker (and delete)" runs. All markers with the same tag>0 will get multi-carets (then markers are deleted). 
** Param len>0 is needed if you want to place selection at marker, with this length, when "goto last marker" goes to this marker.
* MARKERS_DELETE_ALL: Deletes all markers.
* MARKERS_DELETE_LAST: Deletes last added marker.

===attr===

 attr(id, tag=0, x=0, y=0, len=0,
      color_font=0, color_bg=0, color_border=0,
      font_bold=0, font_italic=0, font_strikeout=0,
      border_left=0, border_right=0, border_down=0, border_up=0 )

Controls additional color attributes. Possible values of id:

* MARKERS_ADD: Adds fragment with specified properties. Also gets number of fragments. Props:
** tag: any int value attached to fragment (several plugins must add fragments with different tags, to be able to remove only fragments for them)
** x, y: position of fragment start (like caret).
** len: length of fragment.
** color_nnnn: RGB color values for font, background, borders. E.g. 0x0000FF is red, 0x00FF00 is green.
** font_nnnn: font attributes: 0 - off, 1 - on.
** border_nnnn: border types for edges, values from 0: none, solid, dash, solid 2pixel, dotted, rounded, wave.
* MARKERS_GET: Gets list of fragments, each item is list, int fields, same as function params.
* MARKERS_DELETE_ALL: Deletes all fragments.
* MARKERS_DELETE_LAST: Deletes last added fragment.
* MARKERS_DELETE_BY_TAG: Deletes all fragments for specified tag value.

==Misc==

===save===

 save()

Saves editor's tab to disk. Shows save-as dialog for untitled tab. Gets bool: file was saved.

===cmd===

 cmd(code, text="")

Command runner, it runs any command in editor by its int code.

See codes in module cudatext_cmd. Param text is needed for rare commands (e.g. by cCommand_TextInsert).

===focus===

 focus()

Activates editor's tab and focuses editor itself. It's needed when you want to activate inactive tab. You can get Editor objects of inactive tabs using ed_handles().

===lock/unlock===

 lock()
 unlock()

These lock, then unlock editor. Locked editor is not painted and shows text label "Wait...".

===convert===

 convert(id, x, y)

Converts coordinates in editor. Possible values of id:

* CONVERT_CHAR_TO_COL: Convert char-coordinates (x,y) to column-coordinates 2-tuple (column,y).
* CONVERT_COL_TO_CHAR: Convert column-coordinates (x,y) to char-coordinates 2-tuple (chars,y).

Gets None if coordinates incorrect (e.g. x<0).

===complete===

 complete(text, len1, len2)

Shows auto-completion listbox with given items.

* text: string with items, must be formatted as shown in the [[ATSynEdit#Auto-completion_lists]].
* len1: count of chars to the left of the caret, to be replaced.
* len2: count of chars to the right of the caret, to be replaced.

Note: listbox disappears if you move caret or type text, unlike usual auto-completion listboxes (they can recalculate items for new caret pos).

=Tech info=

==Format of text for cmd_MouseClick==

Text is "X,Y" where X/Y are position of caret relative to top-caret (other carets removed when command runs). If Y is 0, X is addition to caret's x. 
If Y not 0, Y is addition to caret's y, and X is absolute caret's x.

==Format of text for cmd_FinderAction==

Text is chr(1) separated items:

* item 0: find-action, one of: 
** 'findfirst'- find first
** 'findnext'- find next
** 'findprev'- find prev
** 'rep'- replace next, find
** 'repstop'- replace next, don't find
** 'repall'- replace all
** 'findcnt'- count all
** 'findmark'- mark all
* item 1: text to find
* item 2: text to replace with
* item 3: several chars, each char is find-option: 'b' for back, 'c' for case-sens, 'r' for regex, 'w' for whole-words, 'f' for from-caret, 'o' for confirm-replaces, 'a' for wrapped-search

=History=

1.0.119

* add: msg_status_alt
* add: on_func_hint
* add: app_proc: PROC_GET/SET_FIND_OPTIONS
* change: app_log: LOG_GET_LINES result

1.0.118

* add: on_click
* add: on_lexer
* add: ed.set_prop/get_prop PROP_COLOR
* add: ed.set_prop/get_prop PROP_MARKED_RANGE
* add: ed.set_prop/get_prop PROP_CARET_SHAPE*
* delete: dlg_checklist

1.0.117

* add: app_log: LOG_PANEL_ADD, LOG_PANEL_DELETE, LOG_PANEL_FOCUS
* add: app_log: LOG_GET_LINES, LOG_GET_LINEINDEX, LOG_SET_LINEINDEX
* add: ed.set_prop: PROP_EXPORT_HTML
* add: app_proc: PROC_SET_SPLIT, PROC_GET_SPLIT

1.0.116

* add: on_output_nav
* add: app_log: param tag for LOG_ADD
* add: app_proc: PROC_GET_COMMAND_PLUGIN

1.0.115

* add: dlg_custom: props for "edit"; align-chars for "listview"
* add: app_proc: PROC_GET_ESCAPE PROC_SET_ESCAPE

1.0.114

* change: attr() has param "tag"
* add: dlg_custom: some props, added "listview", "checklistview"

1.0.113

* add: dlg_custom
* add: dlg_menu(.., focused)
* add: set_prop PROP_INDEX_GROUP, PROP_INDEX_TAB
* add: result for ed.save(), file_save()

1.0.112

* add: Editor.attr()
* add: app_proc PROC_SET_SUBCOMMANDS
* add: app_proc PROC_EXEC_PLUGIN
* add: get_prop PROP_MACRO_REC
* add: dlg_hotkeys()

1.0.111

* add: Editor.markers()
* add: Editor.save()
* add: get/set_prop PROP_TAB_COLLECT_MARKERS
* add: get/set_prop PROP_TAG
* add: app_proc PROC_GET_LAST_PLUGIN
* add: app_proc PROC_GET_GROUPING, PROC_SET_GROUPING
* add: app_proc PROC_EXEC_PYTHON

1.0.110

* add: on_console_nav

1.0.109

* add: on_start
* add: app_proc PROC_SET_EVENTS

1.0.108

* add: Editor.convert()
* add: Editor.set_prop()
* add: app_proc: PROC_MENU_CLEAR, PROC_MENU_ADD
* add: get_prop/set_prop: PROP_UNPRINTED*.
* add: Editor.get_ranges()

1.0.107

* add: event plugins
* add: lexer_proc()
* change: set_caret()
* del: add_caret()

1.0.106

* add: dlg_file: can take filename "!"
* add: app_path: APP_FILE_SESSION
* add: app_proc: PROC_SAVE_SESSION, PROC_LOAD_SESSION, PROC_SET_SESSION
