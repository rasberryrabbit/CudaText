=Intro=
This is API for [[CudaText]] in Python. 

* Main Py module is cudatext. Main module has constants, funcs, class Editor, objects of class Editor.
* Additional module: cudatext_cmd has constants for command runner func.

=Event plugins=

To make plugin react to events: add Python method to class Command (like methods of command plugin). E.g. method "on_save" will be called by editor's event "file saved". Event methods have additional parameter ed_self: Editor object in which event occured (this object is the same as "ed" in 99% cases, but in rare cases event occurs in non-focused editor, so ed_self ll be not same).

Supported events:

* on_open(self, ed_self): Called after file is opened from disk.
* on_save_pre(self, ed_self): Called before saving file. Method can return False to disable saving, other value is ignored.
* on_save(self, ed_self): Called after saving file.
* on_change(self, ed_self): Called after text is changed.
* on_change_slow(self, ed_self): Called after text is changed, after few seconds. This is for Lint plugins, they need to react to change after a delay.
* on_caret(self, ed_self): Called after caret position/selection changed.
* on_key(self, ed_self, key, state): Called when user presses a key. key is int key code. state is few chars string: "a" if Alt pressed, "c" if Ctrl pressed, "s" if Shift pressed, "m" if Meta (Windows-key) pressed. Method can return False do disable key processing, other return value is ignored.
* on_focus(self, ed_self): Called after editor is focused.
* on_start(self, ed_self): Called once on program start (ignore ed_self).
* on_complete(self, ed_self): Called by auto-completion command (default hotkey: Ctrl+Space). Method should call Editor.complete API. Method must return True if it handled command, otherwise None.  
* on_goto_def(self, ed_self): Called by go-to-definition command (in editor context menu). Method must return True if it handled command, otherwise None.
* on_console(self, ed_self, text): Called on entering text command in Python Console panel. Method can return False to disable internal command processing, other value is ignored. Ignore ed_self.
* on_console_nav(self, ed_self, text): Called on dbl-clicking line, or calling context menu item "Navigate", in Python Console panel. Ignore ed_self, text is line with caret.
* on_macro(self, ed_self, text): Called when command "macros: stop recording" runs. In text the "\n"-separated list of macro items is passed. These items were run after command "macros: start recording" and before command "macros: stop recording".
** if item is "number" then it's simple command.
** if item is "number,string" then it's command with str parameter (usually it's command cCommand_TextInsert).
** if item is "py:string_module,string_method,string_param" then it's call of Python plugin (usually string_param is empty).
** to run each item in log, call ed.cmd(): number is command code, all after comma is parameter text.


Config "plugins.json": Command plugins need registering in section "commands", event plugins need registering in section "events". Event plugins have optional key "lexers" - e.g. "CSS,HTML"; need key "events" - e.g. "on_key,on_open,on_save".

=Global funcs=

===version===

 app_exe_version()

Gets version of program (string).

 app_api_version()

Gets version of API (string, contains 3 numbers, dot-separated).

===app_path===

 app_path(id)

Gets some path. Possible values of id:

* APP_DIR_EXE: Dir of program executable.
* APP_DIR_SETTINGS: Dir "settings".
* APP_DIR_DATA: Dir "data".
* APP_DIR_PY: Dir with Python data "py".
* APP_FILE_SESSION: Filename of session, default is "history session.json" in dir "settings".

===app_proc===

 app_proc(id, text)

Performs application-wide action. Possible values of id:

====Misc====

* PROC_GET_CLIP: Gets clipboard text.
* PROC_SET_CLIP: Copies text to clipboard.
* PROC_GET_GROUPING: Gets grouping mode in program, it's one of GROUPS_nnnn int contants.
* PROC_SET_GROUPING: Sets grouping mode in program, pass str(value) where value is one of GROUPS_nnnn int contants.
* PROC_GET_COMMAND: Gets info on internal command with index int(text), 0-based. Gets tuple: (command_int_code, command_name, hotkey_str_1, hotkey_str_2), or None if index not correct. To enum all commands, increase index from '0', until you get None result.

====Plugin calls====

* PROC_SET_EVENTS: Subscribe plugin to events. Param text must be 4 values ";"-separated: "module_name;event_list;lexer_list;keycode_list". Event_list is what can be written in plugins.json, e.g. "on_open,on_save" or empty str to unsubscribe from all. Lexer_list, keycode_list is what can be written in plugins.json too.
* PROC_GET_LAST_PLUGIN: Gets info about last plugin which run from program. It is str "module_name,method_name", values are empty if no plugins run yet.
* PROC_SET_SUBCOMMANDS: Adds command items for plugin (for fixed module/method). Param text must be ";"-separated: "module_name;method_name;param_list". Param_list is "\n"-separated items. Each item is s_caption+"\t"+s_param_value. s_caption is caption for Commands dialog item, s_param_value is parameter for Python method (it can be any primitive type: 20, None, False, 'Test here', or expression).

====Python====
* PROC_EXEC_PYTHON: Runs Python string in the context of Console (it is not the same as exec() call). Also gets string: result of command.
* PROC_EXEC_PLUGIN: Runs Python plugin's method. Text must be ","-separated: "module_name,method_name,param_string", where param_string can be missed, this is parameter(s) for method.

====Sessions====

* PROC_SAVE_SESSION: Saves session to file with given name. Session is a set of opened named files, group-indexes for files, positions of groups. Session files are JSON.
* PROC_LOAD_SESSION: Loads session from file with given name. 
* PROC_SET_SESSION: Tells to app filename of session. This file will be saved on exit, loaded on start, shown in app title in {} brackets.

====Menus====

* PROC_MENU_ENUM: Gets "\n"-separated string with all items in submenu. Items in form "caption|int_command" or in form "caption|s_module,s_method". Param text must be menu_id.
** menu_id can be: 
*** str(int_value) to specify any submenu by unique int value
*** "top" to specify top menu
*** "top-file"/"top-edit"/"top-sel"/"top-sr"/"top-view"/"top-op"/"top-help" to specify submenus File/Edit/Selection/Search/View/Options/Help
*** "text" to specify editor context menu

* PROC_MENU_CLEAR: Clears some submenu. Param text must be menu_id.

* PROC_MENU_ADD: Adds menu item to some submenu. Param text must be "menu_id;menu_cmd;menu_caption;menu_index". This returns string, str(int_value), with unique int value for added item. Use this string as menu_id for next calls.
** menu_id is submenu item in which you add item. 
** menu_cmd is:
*** str(command_code) - int command code from module cudatext_cmd
*** spec values: 
**** "recents" - recent-files submenu; 
**** "themes" - color-themes submenu; 
**** "plugins" - plugins submenu
*** s_module+","+s_method - method in command plugin. Also allowed to add here ","+s_param - to pass parameter to Python method.
*** 0 (value ignored) if submenu
** menu_caption is caption, or "-" for menu separator.
** menu_index is str(index) for 0-based index at which to insert item; empty param or -1: add item at end.

===app_log===

 app_log(id, text)

Controls panels in the bottom panel: Console, Output, Validate.
Possible values of id:

* LOG_CLEAR: Clears active log panel, text is ignored.
* LOG_ADD: Adds single line to active log panel.
* LOG_SET_PANEL: Sets active log panel, text must be one of values: LOG_PANEL_OUTPUT, LOG_PANEL_VALIDATE.
* LOG_SET_REGEX: Sets parsing regex for active log panel. Regex must have some groups in round brackets, indexes of these groups must be passed in separate API calls. All lines in log panel, which can be parsed by this regex, will allow navigation to source code by click or double-click.
* LOG_SET_LINE_ID: Sets index of regex group for line-number. text is one-char string from "1" to "8", and "0" means "not used".
* LOG_SET_COL_ID: Sets index of regex group for column-number.
* LOG_SET_NAME_ID: Sets index of regex group for file-name.
* LOG_SET_FILENAME: Sets default file-name, which will be used when regex cannot find file-name in a string. 
* LOG_SET_ZEROBASE: Sets flag: line and column numbers are zero-based, not 1-based. text is one-char string "0" or "1".
* LOG_CONSOLE_CLEAR: Clears "Python console" panel. text is ignored.
* LOG_CONSOLE_ADD: Adds line text to "Python console" panel.  
* LOG_CONSOLE_GET: Returns list of "Python console" panel combobox lines. text is ignored. 

'''Example'''

For line "line 10 column 20: text message here" the following regex and indexes can be used:

* regex "\w+ (\d+) \w+ (\d+): .+"
* line-number index "1"
* column-number index "2"
* file-name index "0" (not used)
* zero-base flag "0" (off)

===msg_box===

 msg_box(text, flags)

Shows modal message-box with given text.

Param flags is sum of button-value (OK, OK/Cancel, Yes/No etc) and icon-value (Info, Warning, Error, Question):

* MB_OK
* MB_OKCANCEL
* MB_ABORTRETRYIGNORE
* MB_YESNOCANCEL
* MB_YESNO
* MB_RETRYCANCEL

* MB_ICONERROR
* MB_ICONQUESTION
* MB_ICONWARNING
* MB_ICONINFO

Gets int code of button pressed:

* ID_OK
* ID_CANCEL
* ID_ABORT
* ID_RETRY
* ID_IGNORE
* ID_YES
* ID_NO

===msg_status===

 msg_status(text)

Shows given text in statusbar field.

===dlg_input===

 dlg_input(label, defvalue)

Shows modal dialog to input one string.

Gets entered string or None of cancelled.

===dlg_input_ex===

 dlg_input_ex(number, caption,
               label1   , text1="", label2="", text2="", label3="", text3="",
               label4="", text4="", label5="", text5="", label6="", text6="",
               label7="", text7="", label8="", text8="", label9="", text9="",
               label10="", text10="")

Shows modal dialog to enter 1 to 10 strings. Param number is count of strings.

Gets list of entered strings or None if cancelled.

===dlg_file===

 dlg_file(is_open, init_filename, init_dir, filters)

Shows file-open or file-save-as modal dialog.

Gets filename (str) or None if cancelled. Params:

* is_open: True for open dialog, False for save-as dialog.
* init_filename: Initial filename for save-as dialog. Can be empty.
* init_dir: Initial dir for dialog. Can be empty.
* filters: Sets file filters for dialog. Can be empty. Example, 2 filters: "Texts|*.pas;*.txt|Include|*.inc"

To allow multi-select in open dialog, pass init_filename="*". If single filename selected, result is str. If several filenames selected, result is list of str.

To disable check "filename exists" in open dialog, start init_filename with "!".

===dlg_menu===

 dlg_menu(id, text)

Shows modal menu. 
Gets index of item selected (0-base), or None of cancelled.

Possible values of id:

* MENU_LIST: Dialog with listbox similar to Commands dialog of CudaText, with filter field.
* MENU_LIST_ALT: Like MENU_LIST but each item has 2x height, and instead of right-aligning, part of an item shows below.

Param text is string items, separated by "\n" char. Each item can be simple str or str1+"\t"+str2 (str2 shows right-aligned or below).

===dlg_color===

 dlg_color(value)

Shows select-color dialog with given initial color (int).

Gets int color, or None if cancelled.

===dlg_checklist===

 dlg_checklist(caption, columns, items, size_x, size_y)

Shows dialog with ListView with checkmarks. Returns list of bool: checked states of lines, or None if cancelled. Params:

* caption: dialog caption.
* columns: "\n"-separated column items, each item is "\t"-separated: title and str(column_width), where column_width can be missed or zero for autosize.
* items: "\n"-separated dialog lines, each line is "\t"-separated column strings. 1st column can begin with "*" to check this line.
* size_x: dialog width.
* size_y: dialog height.

===dlg_hotkeys===

 dlg_hotkeys(text)

Shows dialog to configure hotkeys of internal command or plugin. Gets bool: OK pressed and hotkeys saved (to keys.json).

Text can be:

* str(int_command): for internal command codes (module cudatext_cmd).
* "module_name,method_name" or "module_name,method_name,method_param": for command plugin.

===file_open===

 file_open(filename, group=-1)

Opens editor tab with given filename. If filename already opened, activates its tab. Pass empty str to open untitled tab.

Param group is index of tab-group (0-based), default means "current group". If you pass index of currently hidden group, group won't show, you need to call editor command to show it, see [[#cmd]].

Gets bool: filename is empty or sucessfully opened.

Note: "ed" is always the current editor, after file_open() current editor changes, and "ed" is the new cur editor.

===file_save===

 file_save()

Saves current tab to disk. Shows save-as dialog for untitled tab.

===ed_handles===

 ed_handles()

Gets range object: it contains int handles of all editor tabs. Pass each handle to Editor() to make editor object from handle.

Example command in console, prints filenames of all tabs:

<syntaxhighlight>
for h in ed_handles(): print(Editor(h).get_filename())
</syntaxhighlight>

===ini_read/ini_write===

 ini_read(filename, section, key, value)
 ini_write(filename, section, key, value)

Reads or writes single string to ini file. Params:

* filename: Full path of ini file. Can be name w/o path, this means that path of "settings" dir is used.
* section: str: Section of ini file.
* key: str: Key in section.
* value: On write: value to write. On read: default value which is returned if no such filename/section/key is found.

Gets string which is read, gets None on write.

===lexer_proc===

 lexer_proc(id, value)

Do some lexer-related action, get/set property. 

Parameter value gives ";"-separated substrings. Lexer name, if it's needed, is 1st substring. If lexer name needed and incorrect name passed, function gets None.

Possible values of id:

* LEXER_GET_EXT: Gets file-extensions field for given lexer, space-separated.
* LEXER_GET_ENABLED: Gets enabled-flag for given lexer. Usually True, rare lexers have if False (they're unchecked in Lexer Library dialog).
* LEXER_GET_COMMENT: Gets line-comment string for given lexer.
* LEXER_GET_MODIFIED: Gets bool: is lexer library modified and not saved.
* LEXER_GET_LIST: Gets string: "\n"-separated list of lexer names in library.   
* LEXER_GET_LINKS: Gets string: "\n"-separated list of sublexers names in the given lexer. 
* LEXER_GET_STYLES: Gets string: "\n"-separated list of styles names in the given lexer.
* LEXER_SET_NAME: Sets for lexer with given name (substring 1) new name (substring 2).
* LEXER_SET_ENABLED: Sets for lexer with given name enabled-flag (substring 2: "0" or "1").
* LEXER_SET_EXT: Sets for lexer with given name file-extensions field (substring 2).
* LEXER_SET_LINKS: Sets for given lexer - names of its sublexers. Substring 2 must be "|"-separated list of lexer names (any number allowed, only actual number will be used).
* LEXER_SAVE_LIB: Saves lexer library file.
* LEXER_DELETE: Deletes given lexer from library.
* LEXER_IMPORT: Adds new lexer from given filename (substring 1). Gets name of this lexer, or None if import failed.
* LEXER_EXPORT: Saves lexer with given name into file with given name (substring 2). Recommended extension: .lcf.

===more===

=Editor class=

Editor class has methods to work with editor. Global objects of Editor exist:

* ed: refers to currently focused editor (for any tab)
* ed_bro: refers to "brother" of ed. If tab is splitted, 2 editors are shown: 1st/2nd. 1st and 2nd are "brother" editors.

==Carets==
===get_carets===

 get_carets()

Returns list of 4-tuples, each item is info about one caret: (PosX, PosY, EndX, EndY).

* PosX is caret's column (0-base). Tab-chars give x increment 1, like others.
* PosY is caret's line (0-base).
* EndX/EndY is position of selection edge for this caret. Both -1 if no selection for caret.

===set_caret===

 set_caret(posx, posy, endx=-1, endy=-1, id=CARET_SET_ONE)

Controls carets. Possible values of id:

* CARET_SET_ONE: Removes multi-carets and sets single caret with given coords (posx, posy, endx, endy). 
* CARET_ADD: Adds caret (multi-carets feature) with given coords. Also gets count of carets after that (same as len(get_carets()) ).
* CARET_DELETE_ALL: Removes all carets. (Note: you must add caret then to enable text editing to user.)
* CARET_SET_INDEX + N (any N>=0): Changes single caret with index N to given coords.

==Text read/write==

===get_text_all/set_text_all===

 get_text_all()
 set_text_all(text)

Gets/sets entire text in the editor (str).

Note: get_text_all is simple wrapper around get_text_line/get_line_count, it uses "\n" as line sep.

===get_text_line/set_text_line===

 get_text_line(num)
 set_text_line(num, text)

Gets/sets single line (str) with given index (0-base).

Line must be w/o CR LF. Gets None if index incorrect.

To add new line, call set with num=-1.

===get_text_substr===

 get_text_substr(x1, y1, x2, y2)

Gets substring from position (x1, y1) to position (x2, y2). Second position must be bigger than first.

===delete===

 delete(x1, y1, x2, y2)

Deletes range from position (x1, y1) to bigger position (x2, y2). (Too big x1/x2 are allowed).

Note: don't pass tuple from get_carets()[0], this tuple has not sorted pos=(x1, y1), end=(x2, y2), you need to sort them (first sort by y, then by x).

Example replaces selection of 1st caret with text:

<syntaxhighlight lang="Python">
        x0, y0, x1, y1 = ed.get_carets()[0]
        if (y1>y0) or ((y1==y0) and (x1>=x0)):
            pass
        else:
            x0, y0, x1, y1 = x1, y1, x0, y0 
        
        ed.set_caret(x0, y0)
        ed.delete(x0, y0, x1, y1)
        ed.insert(x0, y0, text)
</syntaxhighlight>

===insert===

 insert(x, y, text)

Inserts given text at position (x, y). Text can be multi-line, all CR LF are converted to currently used line-ends.

Gets 2-tuple (x, y) of position after inserted text. It is on the same line, if text is single line.

==Selection==

===get_text_sel===

 get_text_sel()

Returns selected text for 1st caret (empty, if no selection).

===get_sel_mode===

 get_sel_mode()

Gets kind of selection: normal or column selection: SEL_NORMAL, SEL_COLUMN.

===get_sel_lines===

 get_sel_lines()

Gets 2-tuple, indexes of 1st and last lines affected by 1st caret selection. Both -1 if no selection.

===get_sel_rect/set_sel_rect===

 get_sel_rect()
 set_sel_rect(x1, y1, x2, y2)

Gets/sets coords of column selection.

Gets 4-tuple (x1, y1, x2, y2). All 0 if no column selection.

==Properties==

===get_line_count===

 get_line_count()

Gets number of lines.

===get_filename===

 get_filename()

Gets filename (str) of the editor's tab. Empty str for untitled tabs.

===get_tabcolor/set_tabcolor===

 get_tabcolor()
 set_tabcolor(value)

Gets/sets custom color (int) of tab for the editor. It's COLOR_NONE if color is not set.

===get_enc/set_enc===

 get_enc()
 set_enc(value)

Gets/sets encoding name for the editor. It's one of the strings which are visible in the encodings menu of statusbar: "UTF-8", "ANSI" etc.

===get_top/set_top===

 get_top()
 set_top(value)

Gets/sets index of top visible line in the editor.

===get_split/set_split===

 get_split()
 set_split(state, percent)

Gets/sets tab splitting: each tab can be splitted to primary/second editors.

Gets 2-tuple:

* int: state of splitting, one of the values
** TAB_SPLIT_NO: tab not splitted
** TAB_SPLIT_HORZ
** TAB_SPLIT_VERT 
* float: percent of splitting, it's 0.5 if tab splitted 50/50.

===get_prop===

 get_prop(id, text="")

Gets editor's property. 

Param text gives additional parameter(s) if mentioned. Possible values of id:

* PROP_GUTTER_NUM: bool: is gutter column for line numbers shown.
* PROP_GUTTER_FOLD: bool: is gutter column for folding shown.
* PROP_GUTTER_BM: bool: is gutter column for bookmarks shown.
* PROP_EOL: str: end-of-line chars. Currently always gets "\n" since it's ignored in "insert" method.
* PROP_WRAP: int: word-wrap mode. 0: no wrap; 1: wrap at window edge; 2: wrap at fixed margin.
* PROP_RO: bool: read-only mode.
* PROP_TAB_SPACES: bool: tab-key enters spaces.
* PROP_TAB_SIZE: int: size of tab-char.
* PROP_MARGIN: int: position of fixed margin.
* PROP_MARGIN_STRING: str: user-defined margins positions, e.g. "20 25".
* PROP_INSERT: bool: insert/overwrite mode.
* PROP_MODIFIED: bool: editor is modified.
* PROP_RULER: bool: horz ruler is shown.
* PROP_LINE_STATE: int: state of the line with index int(text). One of values: LINESTATE_NORMAL, LINESTATE_CHANGED, LINESTATE_ADDED, LINESTATE_SAVED.
* PROP_LEXER_FILE: str: name of lexer for entire file (empty str if none is active).
* PROP_LEXER_POS: str: name of lexer at specified position: text must be str(column)+","+str(line), column/line 0-based.
* PROP_LEXER_CARET: str: name of lexer at the position of 1st caret.
* PROP_INDEX_GROUP: int: index of group with editor's tab, 0-based.
* PROP_INDEX_TAB: int: index of editor's tab in group, 0-based.
* PROP_UNPRINTED_SHOW: bool: unprinted chars: global enable-flag.
* PROP_UNPRINTED_SPACES: bool: unprinted chars: show spaces/tabs.
* PROP_UNPRINTED_ENDS: bool: unprinted chars: show line ends.
* PROP_UNPRINTED_END_DETAILS: bool: unprinted chars: show line end details.
* PROP_TAB_COLLECT_MARKERS: bool: tab-keys collects (jumps to and deletes) markers (if markers placed).
* PROP_TAG: str: just a string attached to editor's tab (you can put here any value).
* PROP_MACRO_REC: bool: currently macro is recording.

===set_prop===

 set_prop(id, value)

Sets editor's property.

Param value is str. If needed bool - pass "0"/"1"; if needed int - pass str(int_value).
Possible values of id:

* PROP_GUTTER_NUM: bool: show gutter column "line numbers".
* PROP_GUTTER_FOLD: bool: show gutter column "folding".
* PROP_GUTTER_BM: bool: show gutter column "bookmarks".
* PROP_WRAP: int: word-wrap mode. 0: no wrap; 1: wrap at window edge; 2: wrap at fixed margin. 
* PROP_RO: bool: read-only mode.
* PROP_TAB_SPACES: bool: tab-key enters spaces.
* PROP_TAB_SIZE: int: size of tab-char.
* PROP_MARGIN: int: position of fixed margin.
* PROP_MARGIN_STRING: str: space-separated user-margins columns.
* PROP_INSERT: bool: insert/overwrite mode.
* PROP_RULER: bool: show ruler.
* PROP_LEXER_FILE: str: name of lexer.
* PROP_INDEX_GROUP: int: index of group with editor's tab, 0-based.
* PROP_INDEX_TAB: int: index of editor's tab in group, 0-based.
* PROP_UNPRINTED_SHOW: bool: unprinted chars: global enable-flag.
* PROP_UNPRINTED_SPACES: bool: unprinted chars: show spaces/tabs.
* PROP_UNPRINTED_ENDS: bool: unprinted chars: show line ends.
* PROP_UNPRINTED_END_DETAILS: bool: unprinted chars: show line end details.
* PROP_TAB_COLLECT_MARKERS: bool: tab-keys collects (jumps to and deletes) markers.
* PROP_TAG: str: just a string attached to editor's tab (you can put here any value).

===bookmark===

 bookmark(id, nline, nkind=1, ncolor=-1, icon="")

Controls bookmarks. Possible values of id:

* BOOKMARK_GET: Gets kind of bookmark at line=nline. 0 means no bookmark, 1 means usual bookmark.
* BOOKMARK_SET: Sets bookmark with kind=nkind at line=nline. 1 means usual bookmark with usual color and icon. Other kind values mean custom bookmark, which must be setup via BOOKMARK_SETUP.
* BOOKMARK_CLEAR: Removes bookmark from line=nline (nkind ignored).
* BOOKMARK_CLEAR_ALL: Removes all bookmarks (nline, nkind ignored).
* BOOKMARK_SETUP: Setup custom bookmarks with kind=nkind (nline ignored). Setup is:
** ncolor: color of bookmarked line. Can be COLOR_NONE to not show bg-color.
** icon: path to icon file for gutter, .bmp file of size 16x16.
* BOOKMARK_GET_LIST: Gets list of line indexes with bookmarks (nline, nkind ignored).

Notes:

* nkind must be 1..255.
* nkind values 240..249 have setup by default: they have blue icons "0" to "9".

===get_ranges===

 get_ranges()

Gets list of fold-ranges in parsed lexer data. It is list of 5-lists: [y, y2, x, staple, folded].

* y: line of range start.
* y2: line of range end. If y==y2, then range is simple and don't have gutter-mark and staple.
* x: x-offset of range start (char index in start line).
* staple: int (0/1) which shows that range has block staple.
* folded: int (0/1) which shows that range is currently folded.

===markers===

 markers(id, x=0, y=0, tag=0, len=0)

Controls markers (used e.g. in Snippets plugin). Possible values of id:

* MARKERS_GET: Gets list of markers, each item is list [x, y, tag, len]. Gets None if no markers.
* MARKERS_ADD: Adds marker. Also gets number of markers. Props:
** x, y: Start of marker (like caret pos).
** Param tag>0 is needed if you want to place multi-carets when command "goto last marker (and delete)" runs. All markers with the same tag>0 will get multi-carets (then markers are deleted). 
** Param len>0 is needed if you want to place selection at marker, with this length, when "goto last marker" goes to this marker.
* MARKERS_DELETE_ALL: Deletes all markers.
* MARKERS_DELETE_LAST: Deletes last added marker.

===attr===

 attr(id, x=0, y=0, len=0,
      color_font=0, color_bg=0, color_border=0,
      font_bold=0, font_italic=0, font_strikeout=0,
      border_left=0, border_right=0, border_down=0, border_up=0 )

Controls additional color attributes. Possible values of id:

* MARKERS_ADD: Adds fragment with specified properties. Also gets number of fragments. Props:
** x, y: position of fragment start (like caret).
** len: length of fragment.
** color_nnnn: RGB color values for font, background, borders. E.g. 0x0000FF is red, 0x00FF00 is green.
** font_nnnn: font attributes: 0 - off, 1 - on.
** border_nnnn: border types for edges, values from 0: none, solid, dash, solid 2pixel, dotted, rounded, wave.
* MARKERS_GET: Gets list of fragments, each item is list, int fields, same as function params.
* MARKERS_DELETE_ALL: Deletes all fragments.
* MARKERS_DELETE_LAST: Deletes last added fragment.

==Misc==

===save===

 save()

Saves editor's tab to disk. Shows save-as dialog for untitled tab.

===cmd===

 cmd(code, text="")

Command runner, it runs any command in editor by its int code.

See codes in module cudatext_cmd. Param text is needed for rare commands (e.g. by cCommand_TextInsert).

===focus===

 focus()

Activates editor's tab and focuses editor itself. It's needed when you want to activate inactive tab. You can get Editor objects of inactive tabs using ed_handles().

===lock/unlock===

 lock()
 unlock()

These lock, then unlock editor. Locked editor is not painted and shows text label "Wait...".

===convert===

 convert(id, x, y)

Converts coordinates in editor. Possible values of id:

* CONVERT_CHAR_TO_COL: Convert char-coordinates (x,y) to column-coordinates 2-tuple (column,y).
* CONVERT_COL_TO_CHAR: Convert column-coordinates (x,y) to char-coordinates 2-tuple (chars,y).

Gets None if coordinates incorrect (e.g. x<0).

===complete===

 complete(text, len1, len2)

Shows auto-completion listbox with given items.

* text: string with items, must be formatted as shown in the [[ATSynEdit#Auto-completion_lists]].
* len1: count of chars to the left of the caret, to be replaced.
* len2: count of chars to the right of the caret, to be replaced.

Note: listbox disappears if you move caret or type text, unlike usual auto-completion listboxes (they can recalculate items for new caret pos).

=Tech info=

==Format of text for cmd_MouseClick==

Text is "X,Y" where X/Y are position of caret relative to top-caret (other carets removed when command runs). If Y is 0, X is addition to caret's x. 
If Y not 0, Y is addition to caret's y, and X is absolute caret's x.

==Format of text for cmd_FinderAction==

Text is chr(1) separated items:

* item 0: find-action, one of: 'findfirst', 'findnext', 'findprev', 'rep', 'repall', 'findcnt', 'findmark'
* item 1: text to find
* item 2: text to replace with
* item 3: several chars, each char is find-option: 'b' for back, 'c' for case-sens, 'r' for regex, 'w' for whole-words, 'f' for from-caret, 'o' for confirm-replaces, 'a' for wrapped-search

=History=

1.0.113

* add: set_prop PROP_INDEX_GROUP, PROP_INDEX_TAB

1.0.112

* add: Editor.attr()
* add: app_proc PROC_SET_SUBCOMMANDS
* add: app_proc PROC_EXEC_PLUGIN
* add: get_prop PROP_MACRO_REC
* add: dlg_hotkeys()

1.0.111

* add: Editor.markers()
* add: Editor.save()
* add: get/set_prop PROP_TAB_COLLECT_MARKERS
* add: get/set_prop PROP_TAG
* add: app_proc PROC_GET_LAST_PLUGIN
* add: app_proc PROC_GET_GROUPING, PROC_SET_GROUPING
* add: app_proc PROC_EXEC_PYTHON

1.0.110

* add: on_console_nav

1.0.109

* add: on_start
* add: app_proc PROC_SET_EVENTS

1.0.108

* add: Editor.convert()
* add: Editor.set_prop()
* add: app_proc: PROC_MENU_CLEAR, PROC_MENU_ADD
* add: get_prop/set_prop: PROP_UNPRINTED*.
* add: Editor.get_ranges()

1.0.107

* add: event plugins
* add: lexer_proc()
* change: set_caret()
* del: add_caret()

1.0.106

* add: dlg_file: can take filename "!"
* add: app_path: APP_FILE_SESSION
* add: app_proc: PROC_SAVE_SESSION, PROC_LOAD_SESSION, PROC_SET_SESSION
